<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[厉害了，七牛云 CEO 来讲架构了！]]></title>
    <url>%2Fcourse-qiniu-ceo.html</url>
    <content type="text"><![CDATA[说起许式伟，你应该不陌生，他是七牛云的CEO，ECUG 社区发起人，国内 Go 语言圈的领军人物，曾就职于金山、盛大，有超过 10 年的搜索和分布式存储相关技术的研发经验。他的个人经历颇为传奇，大学时外号“ C 狂”，凭一份在招聘现场临时写就的简历，成功应聘金山，毕业仅 2 年就成为了首席架构师，主导 WPS Office 2005 长达 3 年的架构设计和开发。2011 年，许式伟创立了七牛云，专注企业级存储服务。 许式伟的架构课想要做架构，空有一身技术是远远不够的，知识的深度和广度，往往会决定一个架构师的架构能力。而这些知识，从你踏入 IT 行业那一刻起，甚至更早就应该开始储备了。栈长看到很多人，做了 7、8 年程序员，仍然停留在「码农」的阶段，平时工作节奏太快，很难有机会系统学习架构，也没人教，只能闷头敲代码，越来越被动。早在几个月前，栈长就听说七牛云CEO要在极客时间上开课讲架构，说真的我挺惊讶，行业里有这样背景和资历的架构师实在是太少了，老许是为数不多的能把「架构」这事儿讲清楚的人。 扫码试读或订阅 我为什么要推荐这个专栏？老许这个人，在技术圈里是出了名的低调，江湖上的「人狠话不多」说的就是他这种。这是他第一次完整系统地分享自己的架构经验，是一个架构师 20 年的经验沉淀，实在难得。看了开篇词和前面的几篇文章，我更加坚定了自己的判断。限时99元，不到 100 块钱就能看到许式伟 20 年的经验总结，获得与顶尖架构师更近一步的机会。几年后的你，会感谢自己今天的投资。👇点击「阅读原文」，跟着老许学架构。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>极客时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级架构师全套课程（咕泡）]]></title>
    <url>%2Fcourse-java-gupao.html</url>
    <content type="text"><![CDATA[高级架构师全套课程（咕泡）百度网盘分享链接: https://pan.baidu.com/s/1yFtiPsIcDGFyELJHl4wjQg视频也是从网上找了好久才找的的。我还没有看过，不过同事说高级教程还不错。就想拿出来分享给大家，具体的提取码还需要大家打赏后发送邮件到server.tec@qq.com获取。 土豪网友 邮箱 打赏方式 打赏金额 打赏时间 B*I 190***@qq.com 微信 ¥10.00 2019-04-16 21:07:34 附一些截图： 下面是打赏方式]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>咕泡学院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot上传图片踩的坑]]></title>
    <url>%2Fspringboot-fileupload.html</url>
    <content type="text"><![CDATA[最近项目里面有个需求，要上传图片到阿里云的OSS服务。所以需要写个上传图片的接口给前端。这个简单的接口本来就给分配了1个工时，感觉也蛮简单的。但编码过程中遇到了好几个问题，现在一一记录下来，避免再次踩坑。 1、图片不能超过1M报错信息：1org.springframework.web.multipart.MultipartException: Could not parse multipart servlet request; nested exception is java.lang.IllegalStateException: org.apache.tomcat.util.http.fileupload.FileUploadBase$FileSizeLimitExceededException: The field file exceeds its maximum permitted size of 1048576 bytes. 分析原因：图片大小超过了最大限制大小1048576 bytes=1MB，在1234解决方案： 在application.properties中配置 ```propertiesspring.http.multipart.maxFileSize = 10MB 2、图片不能超过10M，连接重置报错信息：1org.springframework.web.multipart.MultipartException: Could not parse multipart servlet request; nested exception is java.lang.IllegalStateException: org.apache.tomcat.util.http.fileupload.FileUploadBase$SizeLimitExceededException: the request was rejected because its size (10559924) exceeds the configured maximum (10485760) 前端报错：Status：(failed)net::ERR_CONNECTION_RESET 分析原因：请求大小超过了最大限制大小10485760 bytes=10MB，在123456789101112131415解决方案： ```java@RestControllerAdvice@ResponseStatus(HttpStatus.BAD_REQUEST)public class MultipartExceptionConfigHandler &#123; private final Logger logger = LoggerFactory.getLogger(getClass()); @ExceptionHandler(MultipartException.class) public MsCommonResult handleMultipartException(MultipartException icEx, HttpServletRequest request) &#123; logger.warn(&quot;请求业务报错 uri: &#123;&#125;, message: &#123;&#125; &quot;, request.getRequestURI(), icEx.getMessage()); return MsCommonResult.fail(&quot;禁止上传大文件到服务器&quot;); &#125;&#125; 配置ExceptionHandler后，但是并没有返回给前端400的状态码。继续研究后注意到12345678910111213继续解决： ```java@Beanpublic TomcatEmbeddedServletContainerFactory tomcatEmbedded() &#123; TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory(); tomcat.addConnectorCustomizers((TomcatConnectorCustomizer) connector -&gt; &#123; if ((connector.getProtocolHandler() instanceof AbstractHttp11Protocol&lt;?&gt;)) &#123; // -1 means unlimited ((AbstractHttp11Protocol&lt;?&gt;) connector.getProtocolHandler()).setMaxSwallowSize(-1); &#125; &#125;); return tomcat;&#125; 至此，前台收到返回，返回信息如下：12345678HTTP/1.1 400X-Application-Context: ms.maker.company:8071Content-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedDate: Wed, 05 Dec 2018 09:37:58 GMTConnection: close&#123;&quot;result&quot;:500,&quot;detail&quot;:&quot;禁止上传大文件到服务器&quot;,&quot;data&quot;:null&#125; 3、Linux服务器返回413：Request Entity too large报错信息：12345678910111213&lt;html&gt;&lt;head&gt;&lt;title&gt;413 Request Entity Too Large&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="white"&gt;&lt;center&gt;&lt;h1&gt;413 Request Entity Too Large&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.12.2&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt; 分析原因：图片大小超过1M时，提示该信息。经研究nginx的client_max_body_size默认大小为1m。 解决方案：1在http/server/location段配置client_max_body_size: 10m即可。 4、返回JSON，IE9及低版本接受返回后，提示文件下载原因：后台响应的Content-Type为“application/json”，IE浏览器不识别。将返回的数据由对象转为json字符串，浏览器竟然可以自动识别解析。解决方案：12345678910111213方案一：@PostMapping(value = "/aliyunOssUpload", produces = "text/html;charset=UTF-8")public String aliyunOssUpload(@RequestParam("file") MultipartFile uploadFile)方案二：@PostMapping(value = "/aliyunOssUpload")public String aliyunOssUpload(@RequestParam("file") MultipartFile uploadFile, HttpServletResponse response) &#123; response.setContentType("text/html;charset=UTF-8");&#125;方案三：@PostMapping(value = "/aliyunOssUpload")public String aliyunOssUpload(@RequestParam("file") MultipartFile uploadFile, HttpServletResponse response) &#123; response.setHeader("Content-Type", "text/html;charset=UTF-8");&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>spring boot</tag>
        <tag>文件上传</tag>
        <tag>上传文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法学习-commonmark]]></title>
    <url>%2Fmarkdown-commonmark.html</url>
    <content type="text"><![CDATA[CommonMark是markdown的解析器，以下是部分学习链接： commonmark规范https://spec.commonmark.org/ commonmark帮助https://commonmark.org/help/ commonmark教程https://commonmark.org/help/tutorial/ commonmark试一下http://www.commonmark.cn/dingus/ markdown语法 斜体、强调 代码：“_” “__” “*” “**” 1234*Italics***Italics**_Italics___Italics__ 效果： ItalicsItalicsItalicsItalics 段落 代码：“空行” “ ” “\” 12345Imust eat\something. 效果：I musteat\something. 标题 代码：“# ” “## ” “### ” “#### ” “##### ” “###### ” 123456# 一级标题 ### 二级标题 #### 三级标题 ##### 四级标题 ###### 五级标题 ####### 六级标题 # 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 块引用 代码：“&gt; ” 1&gt; 这是一行块引用 效果： 这是一行块引用 列表 代码：“*” “+” “-” “1.” “1)” 12345* 第一行+ 第二行- 第三行1. 第一行1) 第一行 效果： 第一行 第二行 第三行 第一行1) 第一行 链接 代码：“” “[name](url)” “[name][id] [id]:url “title”” 1234行内链接：[百度](https://www.baidu.com)引用链接：[阿里云][1] [1]: https://www.aliyum.com "阿里云" 效果： 行内链接：百度引用链接：阿里云 图片 代码：“![name](url)” “![][id] [id]:url “title”” 1234![](https://www.tencent.com/images/global/footer_logo.png) ![图片链接][2][2]: https://www.tencent.com/images/global/footer_logo.png "腾讯Logo" 效果： 代码块 代码：“” “ ” “\“” “” 123456```markdownA`B`C A B C 效果： ABC A B C 123ABC]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合类-ArrayList源码解析]]></title>
    <url>%2Fcollection-arraylist.html</url>
    <content type="text"><![CDATA[看JDK源码，个人感觉可以从属性、构造方法、常用方法着手，再通篇学习源码。JDK：1.8.0_121Idea：2018.3.4 简介ArrayList是一个容量动态扩张的集合，实现了RandomAccess接口，支持随机访问，初始容量10，最大容量Integer.MAX_VALUE - 8（2147483640），每次调用ArrayList的新增或者删除等修改方法，继承自AbstactList抽象类的属性modCount都会自增，当通过Interactor遍历集合时，只要modCount被其他线程修改，就会抛出ConcurrentModificationException。ArrayList是线程不安全的类，因为它的操作自身集合属性的方法没有进行同步也不是原子性操作，所以会出现不一致现象，可以通过List list = Collections.synchronizedList(new ArrayList(…))把它转成线程安全的集合，当然只是封装了对ArrayList的操作，保存同步而已，性能不是很高，所有的修改操作都要一个个同步。 概览类图 类型定义12345public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; …&#125; 属性来自自身的成员变量：1234567private static final long serialVersionUID = 8683452581122892189L;private static final int DEFAULT_CAPACITY = 10private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData;private int size;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 来自父类和接口的成员变量：1protected transient int modCount = 0; 刚开始学Java的时候，我们掌握了一条定理：ArrayList是底层通过数组实现的。 elementData真正存放对象的数组 DEFAULT_CAPACITY默认初始化容量 serialVersionUID序列化ID，序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。 EMPTY_ELEMENTDATA使用部分构造方法创建对象时，给elementData赋值的空数组 DEFAULTCAPACITY_EMPTY_ELEMENTDATA使用默认构造方法创建对象时，给elementData赋值的默认空数组 modCount操作技术，对elementData操作时会调整modCount MAX_ARRAY_SIZE数组的最大长度，当超过此值会，数组允许扩容到Integer.MAX_VALUE 问题1：elementData前添加了transient，我们知道transient的作用是让某些被修饰的成员属性变量不被序列化，那么在执行时序列化时，为何输出了elementData中的对象？ 构造方法1234567891011121314151617181920212223242526public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125;]]></content>
      <categories>
        <category>JDK源码</category>
      </categories>
      <tags>
        <tag>Java集合类</tag>
        <tag>ArrayList</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我也学习JAVA多线程-join]]></title>
    <url>%2Fthread-join.html</url>
    <content type="text"><![CDATA[在工作中，挺少遇到join关键字，但很多多线程资料和面试过程中，初中级开发工程师总会遇到join。今天一起学习下join。join的作用：等待指定的时间（当为0时，一直等待），直到这个线程执行结束。先看join方法的定义，join是java.lang.Thread的一个普通方法。1234567891011package java.lang;// Thread竟然实现了Runnable接口，之前好像注意到过，但是没在意。// 根据构造方法和run()方法可以看出，本质还是执行的Runnable的实现。public class Thread implements Runnable &#123; … public final void join() throws InterruptedException &#123; join(0); &#125; …&#125; 演示代码12345678910111213141516171819202122public class ThreadLearnJoin &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + "睡觉"); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "起床"); &#125; &#125;, "sub-thread"); t.start(); System.out.println(Thread.currentThread().getName() + "线程join前"); t.join(); System.out.println(Thread.currentThread().getName() + "线程join后"); &#125;&#125; 执行结果1234main线程join前sub-thread睡觉sub-thread起床main线程join后 源码分析继续分析join(0)的代码，首先需要注意的是synchronized关键字，其次是isAlive()和wait(0)。在演示代码中，主线程调用名称为sub-thread的子线程t的join()方法。主线程先获取t对象上的锁，并且当t为Alive状态时，继续调用t的wait(0)方法。由于wait()方法是父类Object的方法，跟子线程t的执行并没有任何关系，wait()会释放t对象上的锁，并阻塞当前main线程。直到子线程t执行结束，main线程继续执行，方法结束。这里也就隐藏了一个点：t线程调用start()后，进入执行状态，运行run()方法中的代码，和t对象上的锁并没有任何关系。run方法并没有进入synchronized的同步区。123456789public final synchronized void join(long millis) throws InterruptedException &#123; … if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; …&#125; 参考资料 Java多线程系列–“基础篇”08之 join()以下是Java多线程系列–“基础篇”08之 join()的评论，可以帮助大家理解记忆。 123456789问题：虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。 那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让&quot;子线程等待才对(因为调用子线程对象s的wait方法嘛)&quot;？ 答案：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！这个这么讲的不清楚吧?调用wait()方法 应该是当前线程持有的对象调用wait() 让线程等，并释放对象锁。在主线程中调用了s.join() join()方法用synchronized修饰了，也就是说当前主线程已经持有了s的锁 这个调用s这个对象wait()方法 让主线程等待并释放s对象锁。 Java join()使用及源码分析]]></content>
      <categories>
        <category>我也学习JAVA多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>join</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[request.getSession(true/false)的区别]]></title>
    <url>%2Frequest-getsession.html</url>
    <content type="text"><![CDATA[javax.servlet.http.HttpServletRequest接口有两个方法：getSession(boolean)和getSession()。具体什么区别，跟踪源码分析下，先摆出结论：request.getSession(true)：获取session,如果session不存在，就新建一个。reqeust.getSession(false)获取session,如果session不存在，则返回null。Debug时，查看HttpServletRequest接口的实现类为RequestFacade。使用Idea查看RequestFacade的代码实现，可以看出是通过Facade外观模式对org.apache.catalina.connector.Request进行了封装。继续看getSession()的源码，其实是调用了getSession(true)。具体是调用了request.getSession(create)。1234567891011121314151617181920212223242526@Overridepublic HttpSession getSession(boolean create) &#123; if (request == null) &#123; throw new IllegalStateException( sm.getString("requestFacade.nullRequest")); &#125; if (SecurityUtil.isPackageProtectionEnabled())&#123; return AccessController. doPrivileged(new GetSessionPrivilegedAction(create)); &#125; else &#123; return request.getSession(create); &#125;&#125;@Overridepublic HttpSession getSession() &#123; if (request == null) &#123; throw new IllegalStateException( sm.getString("requestFacade.nullRequest")); &#125; // 直接调用getSession(true) return getSession(true);&#125; 进入到Request.getSession(boolean)，根据注释看出，create为true时，如果HttpSession不存在，会创建一个新的HttpSession。123456789101112131415/** * @return the session associated with this Request, creating one * if necessary and requested. * * @param create Create a new session if one does not exist */@Overridepublic HttpSession getSession(boolean create) &#123; Session session = doGetSession(create); if (session == null) &#123; return null; &#125; return session.getSession();&#125; 继续进入到doGetSession(boolean create)方法，继续分析。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114protected Session doGetSession(boolean create) &#123; // There cannot be a session if no context has been assigned yet Context context = getContext(); if (context == null) &#123; return (null); &#125; // Return the current session if it exists and is valid // 如果当前session存在且有效，返回当前session if ((session != null) &amp;&amp; !session.isValid()) &#123; session = null; &#125; if (session != null) &#123; return (session); &#125; // Return the requested session if it exists and is valid // 这里有读写锁控制并发 Manager manager = context.getManager(); if (manager == null) &#123; return (null); // Sessions are not supported &#125; if (requestedSessionId != null) &#123; try &#123; session = manager.findSession(requestedSessionId); &#125; catch (IOException e) &#123; session = null; &#125; if ((session != null) &amp;&amp; !session.isValid()) &#123; session = null; &#125; if (session != null) &#123; session.access(); return (session); &#125; &#125; // Create a new session if requested and the response is not committed // create为false时，返回null；create为true时创建一个新的session if (!create) &#123; return (null); &#125; if (response != null &amp;&amp; context.getServletContext() .getEffectiveSessionTrackingModes() .contains(SessionTrackingMode.COOKIE) &amp;&amp; response.getResponse().isCommitted()) &#123; throw new IllegalStateException( sm.getString("coyoteRequest.sessionCreateCommitted")); &#125; // Re-use session IDs provided by the client in very limited // circumstances. String sessionId = getRequestedSessionId(); if (requestedSessionSSL) &#123; // If the session ID has been obtained from the SSL handshake then // use it. &#125; else if (("/".equals(context.getSessionCookiePath()) &amp;&amp; isRequestedSessionIdFromCookie())) &#123; /* This is the common(ish) use case: using the same session ID with * multiple web applications on the same host. Typically this is * used by Portlet implementations. It only works if sessions are * tracked via cookies. The cookie must have a path of "/" else it * won't be provided for requests to all web applications. * * Any session ID provided by the client should be for a session * that already exists somewhere on the host. Check if the context * is configured for this to be confirmed. */ if (context.getValidateClientProvidedNewSessionId()) &#123; boolean found = false; for (Container container : getHost().findChildren()) &#123; Manager m = ((Context) container).getManager(); if (m != null) &#123; try &#123; if (m.findSession(sessionId) != null) &#123; found = true; break; &#125; &#125; catch (IOException e) &#123; // Ignore. Problems with this manager will be // handled elsewhere. &#125; &#125; &#125; if (!found) &#123; sessionId = null; &#125; &#125; &#125; else &#123; sessionId = null; &#125; session = manager.createSession(sessionId); // Creating a new session cookie based on that session if (session != null &amp;&amp; context.getServletContext() .getEffectiveSessionTrackingModes() .contains(SessionTrackingMode.COOKIE)) &#123; Cookie cookie = ApplicationSessionCookieConfig.createSessionCookie( context, session.getIdInternal(), isSecure()); response.addSessionCookieInternal(cookie); &#125; if (session == null) &#123; return null; &#125; session.access(); return session;&#125; StandardContext跟session没有啥关系，就是学习下StandardContext的源码及ReentrantReadWriteLock。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Override public Manager getManager() &#123; Lock readLock = managerLock.readLock(); readLock.lock(); try &#123; return manager; &#125; finally &#123; readLock.unlock(); &#125; &#125; @Override public void setManager(Manager manager) &#123; Lock writeLock = managerLock.writeLock(); writeLock.lock(); Manager oldManager = null; try &#123; // Change components if necessary oldManager = this.manager; if (oldManager == manager) return; this.manager = manager; // Stop the old component if necessary if (oldManager instanceof Lifecycle) &#123; try &#123; ((Lifecycle) oldManager).stop(); ((Lifecycle) oldManager).destroy(); &#125; catch (LifecycleException e) &#123; log.error("StandardContext.setManager: stop-destroy: ", e); &#125; &#125; // Start the new component if necessary if (manager != null) &#123; manager.setContext(this); &#125; if (getState().isAvailable() &amp;&amp; manager instanceof Lifecycle) &#123; try &#123; ((Lifecycle) manager).start(); &#125; catch (LifecycleException e) &#123; log.error("StandardContext.setManager: start: ", e); &#125; &#125; &#125; finally &#123; writeLock.unlock(); &#125; // Report this property change to interested listeners support.firePropertyChange("manager", oldManager, manager); &#125; 结论：request.getSession(true)：获取session,如果session不存在，就新建一个。reqeust.getSession(false)获取session,如果session不存在，则返回null。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RestTemplate--解决中文乱码]]></title>
    <url>%2Frest-template-messycode.html</url>
    <content type="text"><![CDATA[在开发扇贝-每日一句时，使用RestTemplate请求扇贝接口，并保存返回的数据。原本正常的代码，经过架构升级后，请求接口时，会返回乱码数据。经过直接访问接口等形式，最终确认是RestTemplate这个bean有问题。对RestTemplate的声明也比较简单，通过对apache的httpclient进行封装，返回bean实例。代码如下：1234@BeanRestTemplate restTemplate() &#123; return new RestTemplate(httpRequestFactory());&#125; 通过断点debug发现以String格式接收数据时，底层采用的是StringHttpMessageConverter来处理请求。查看RestTemplate的构造方法如下：12345678910111213141516171819202122232425262728293031323334353637public RestTemplate() &#123; this.messageConverters = new ArrayList(); this.errorHandler = new DefaultResponseErrorHandler(); this.uriTemplateHandler = new DefaultUriBuilderFactory(); this.headersExtractor = new RestTemplate.HeadersExtractor(); this.messageConverters.add(new ByteArrayHttpMessageConverter()); this.messageConverters.add(new StringHttpMessageConverter()); this.messageConverters.add(new ResourceHttpMessageConverter(false)); this.messageConverters.add(new SourceHttpMessageConverter()); this.messageConverters.add(new AllEncompassingFormHttpMessageConverter()); if (romePresent) &#123; this.messageConverters.add(new AtomFeedHttpMessageConverter()); this.messageConverters.add(new RssChannelHttpMessageConverter()); &#125; if (jackson2XmlPresent) &#123; this.messageConverters.add(new MappingJackson2XmlHttpMessageConverter()); &#125; else if (jaxb2Present) &#123; this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter()); &#125; if (jackson2Present) &#123; this.messageConverters.add(new MappingJackson2HttpMessageConverter()); &#125; else if (gsonPresent) &#123; this.messageConverters.add(new GsonHttpMessageConverter()); &#125; else if (jsonbPresent) &#123; this.messageConverters.add(new JsonbHttpMessageConverter()); &#125; if (jackson2SmilePresent) &#123; this.messageConverters.add(new MappingJackson2SmileHttpMessageConverter()); &#125; if (jackson2CborPresent) &#123; this.messageConverters.add(new MappingJackson2CborHttpMessageConverter()); &#125;&#125; 其中的StringHttpMessageConverter构造方法使用了默认字符集：ISO-8859-1。1234567891011public class StringHttpMessageConverter extends AbstractHttpMessageConverter&lt;String&gt; &#123; public static final Charset DEFAULT_CHARSET; …… public StringHttpMessageConverter() &#123; this(DEFAULT_CHARSET); &#125; …… static &#123; DEFAULT_CHARSET = StandardCharsets.ISO_8859_1; &#125;&#125; private final List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters根据RestTemplate的构造方法的源码得知所有的HttpMessageConverter都是放在final List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters这个常量集合中。虽然集合不可修改，但是可以对其中的元素StringHttpMessageConverter进行修改。解决方案思路都是将ISO-8859-1的StringHttpMessageConverter替换为UTF-8的StringHttpMessageConverter。 示例代码一 1restTemplate.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8)); 示例代码二 12345for (HttpMessageConverter&lt;?&gt; httpMessageConverter : restTemplate.getMessageConverters()) &#123; if (httpMessageConverter instanceof StringHttpMessageConverter) &#123; ((StringHttpMessageConverter) httpMessageConverter).setDefaultCharset(StandardCharsets.UTF_8); &#125;&#125; 示例代码三 12345// stream .findFirst(); 也是可以的Optional&lt;HttpMessageConverter&lt;?&gt;&gt; converter = restTemplate.getMessageConverters().stream().filter(c -&gt; c instanceof StringHttpMessageConverter).findAny();if(converter.isPresent()) &#123; ((StringHttpMessageConverter) converter.get()).setDefaultCharset(StandardCharsets.UTF_8);&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>RestTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx location配置详细解释]]></title>
    <url>%2Fnginx-location.html</url>
    <content type="text"><![CDATA[语法规则location [=|~|~*|^~] /uri/ { … } = 开头表示精确匹配 ^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。以xx开头 ~ 开头表示区分大小写的正则匹配 以xx结尾 ~* 开头表示不区分大小写的正则匹配 以xx结尾 !~和!~*分别为区分大小写不匹配及不区分大小写不匹配 的正则 / 通用匹配，任何请求都会匹配到。 匹配顺序首先精确匹配 = -&gt; 其次以xx开头匹配^~ -&gt; 然后是按文件中顺序的正则匹配 -&gt; 最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。 常用的location匹配规则 配置指定文件名 12345# iconlocation = /favicon.ico &#123; root images; # 文件在images目录中 expires 7d; # 缓存7天&#125; 根据文件名模糊匹配 1234# 百度统一验证location ~* ^/baidu_verify_[\w]+.html$ &#123; root html;&#125; 路径部分匹配 12345# 静态图片location ^~ /cdn-images/ &#123; alias images/; # 注意使用的alias及后面的/ expires 7d;&#125; 动静分离 12345678910111213# 静态文件location ~* \.(html|jpg|png)$ &#123; root cloud-web; index index.html index.htm;&#125; # 动态请求location ~* /hbm/ &#123; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://10.0.1.210:8769;&#125;]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>location</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《一别两宽，各生欢喜》]]></title>
    <url>%2Fyblkgshx.html</url>
    <content type="text"><![CDATA[放妻协议在敦煌莫高窟出土的“放妻协议” 凡为夫妇之因，前世三生结缘，始配今生之夫妇。若结缘不合，比是怨家，故来相对……既以二心不同，难归一意，快会及诸亲，各还本道。愿妻娘子相离之后，重梳婵鬓，美妇娥眉，巧逞窈窕之姿，选聘高官之主。解怨释结，更莫相憎。一别两宽，各生欢喜。 简单的解释，就是丈夫说：如果我们结合在一起是错误，不如痛快地分手来得超脱，希望你重整山河再攀高枝，也胜过两人看不顺眼互相挤兑。 从这份协议书中我们不难看出，这的确是一份类似于我们今天的离婚协议，但这份协议的内容也只单单说了夫妻离婚的原因：感情不和。于是请来双亲父母和亲戚朋友，做此见证，好聚好散，最后，男方还不忘给妻子一些美好的祝愿。 从这份协议书中我们并没有看到男尊女卑的一面，看到的反而是男女平等，改嫁似乎也是很正常的现象。这样一份“放妻协议”也许在今天看来，人们都还很羡慕，男方有如此的宽宏胸襟，女方也有自由选择的权利。在封建社会里，人们也能如此的和平分手真是令人感到惊奇。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>放妻协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《古艳歌》]]></title>
    <url>%2Fguyange.html</url>
    <content type="text"><![CDATA[出处【出处】《古艳歌》【作者】无名氏（汉）【朝代】汉代【条目】 茕（qióng）茕白兔， 东走西顾。 衣不如新， 人不如故。 解释【注释】这篇最初见于《太平御览》卷六百八十九，题为《古艳歌》，作者无名氏。明、清人选本往往作窦玄妻《古怨歌》。《艺文类聚》卷三十记窦玄妻事云：“后汉窦玄形貌绝异，天子以公主妻之。旧妻与玄书别曰：‘弃妻斥女敬白窦生：卑贱鄙陋，不如贵人。妾日已远，彼日已亲。何所告诉，仰呼苍天。悲哉窦生！衣不厌新，人不厌故。悲不可忍，怨不自去。彼独何人，而居是处。’”并不曾提到窦玄妻作这首歌。今仍从《太平御览》。这首诗是弃妇诗，上二句比喻自己被出而终恋故人，下二句是说服故人也应该念旧。【解释】乐府《古艳歌》：“茕茕（孤独，无依靠）白兔，东走西顾。衣不如新，人不如故。”这首诗的前两句即以动物起兴，兴中兼含比喻。写弃妇被迫出走，犹如孤苦的白兔，往东去却又往西顾，虽走而仍恋故人。后两句是规劝故人应当念旧。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>古艳歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《增关贤文》]]></title>
    <url>%2Fzengguangxianwen.html</url>
    <content type="text"><![CDATA[上集昔时贤文，诲汝谆谆。集韵增广，多见多闻。观今宜鉴古，无古不成今。知己知彼，将心比心。酒逢知己饮，诗向会人吟。相识满天下，知心能几人？相逢好似初相识，到老终无怨恨心。近水知鱼性，近山识鸟音。易涨易退山溪水，易反易覆小人心。运去金成铁，时来铁似金。读书须用意，一字值千金。逢人且说三分话，未可全抛一片心。有意栽花花不发，无心插柳柳成荫。画虎画皮难画骨，知人知面不知心。钱财如粪土，仁义值千金。流水下滩非有意，白云出岫本无心。当时若不登高望，谁信东流海洋深？路遥知马力，日久见人心。两人一般心，无钱堪买金；一人一般心，有钱难买针。相见易得好，久住难为人。马行无力皆因瘦，人不风流只为贫。饶人不是痴汉，痴汉不会饶人。是亲不是亲，非亲却是亲。美不美，乡中水；亲不亲，故乡人。莺花犹怕春光老，岂可教人枉度春？相逢不饮空归去，洞口桃花也笑人。红粉佳人休使老，风流浪子莫教贫。在家不会迎宾客，出门方知少主人。黄芩无假，阿魏无真。客来主不顾，自是无良宾。良宾主不顾，应恐是痴人。贫居闹市无人问，富在深山有远亲。谁人背后无人说，哪个人前不说人？有钱道真语，无钱语不真。不信但看筵中酒，杯杯先劝有钱人。闹市挣钱，静处安身。来如风雨，去似微尘。长江后浪推前浪，世上新人换旧人。近水楼台先得月，向阳花木早逢春。古人不见今时月，今月曾经照古人。先到为君，后到为臣。莫道君行早，更有早行人。莫信直中直，须防仁不仁。山中有直树，世上无直人。自恨枝无叶，莫怨太阳偏。大家都是命，半点不由人。一年之计在于春，一日之计在于晨。一家之计在于和，一生之计在于勤。责人之心责己，恕己之心恕人。守口如瓶，防意如城。宁可人负我，切莫我负人。再三须慎意，第一莫欺心。虎生犹可近，人熟不堪亲。来说是非者，便是是非人。远水难救近火，远亲不如近邻。有茶有酒多兄弟，急难何曾见一人？人情似纸张张薄，世事如棋局局新。山中也有千年树，世上难逢百岁人。力微休负重，言轻莫劝人。无钱休入众，遭难莫寻亲。平生不做皱眉事，世上应无切齿人。士乃国之宝，儒为席上珍。若要断酒法，醒眼看醉人。求人须求英雄汉，济人须济急时无。渴时一滴如甘露，醉后添杯不如无。久住令人贱，频来亲也疏。酒中不语真君子，财上分明大丈夫。贫贱之交不可忘，糟糠之妻不下堂。出家如初，成佛有余。积金千两，不如明解经书。养子不教如养驴，养女不教如养猪。有田不耕仓廪虚，有书不读子孙愚。仓廪虚兮岁月乏，子孙愚兮礼仪疏。听君一席话，胜读十年书。人不通今古，马牛如襟裾。茫茫四海人无数，哪个男儿是丈夫？白酒酿成缘好客，黄金散尽为诗书。救人一命，胜造七级浮屠。城门失火，殃及池鱼。庭前生瑞草，好事不如无。欲求生富贵，须下死工夫。百年成之不足，一旦坏之有余。人心似铁，官法如炉。善化不足，恶化有余。水至清则无鱼，人至察则无徒。知者减半，愚者全无。在家由父，出嫁从夫。痴人畏妇，贤女敬夫。是非终日有，不听自然无。竹篱茅舍风光好，道院僧房终不如。宁可正而不足，不可邪而有余。宁可信其有，不可信其无。命里有时终须有，命里无时莫强求。道院迎仙客，书堂隐相儒。庭栽栖凤竹，池养化龙鱼。结交须胜己，似我不如无。但看三五日，相见不如初。人情似水分高下，世事如云任卷舒。会说说都是，不会说无理。磨刀恨不利，刀利伤人指。求财恨不多，财多害自己。知足常足，终身不辱；知止常止，终身不耻。有福伤财，无福伤己。失之毫厘，谬以千里。若登高必自卑，若涉远必自迩。三思而行，再思可矣。使口不如亲为，求人不如求己。小时是兄弟，长大各乡里。嫉财莫嫉食，怨生莫怨死。人见白头嗔，我见白头喜。多少少年郎，不到白头死。墙有缝，壁有耳。好事不出门，坏事传千里。若要人不知，除非己莫为。为人不做亏心事，半夜敲门心不惊。贼是小人，智过君子。君子固穷，小人穷斯滥矣。贫穷自在，富贵多忧。不以我为德，反以我为仇。宁向直中取，不可曲中求。人无远虑，必有近忧。知我者谓我心忧，不知我者谓我何求？晴天不肯去，直待雨淋头。成事莫说，覆水难收。是非只为多开口，烦恼皆因强出头。忍得一时之气，免得百日之忧。近来学得乌龟法，得缩头时且缩头。惧法朝朝乐，欺心日日忧。人生一世，草长一秋。月过十五光明少，人到中年万事休。儿孙自有儿孙福，莫为儿孙做马牛。为人莫做千年计，三十河东四十西。人生不满百，常怀千岁忧。今朝有酒今朝醉，明日愁来明日忧。路逢险处须回避，事到临头不自由。人贫不语，水平不流。一家养女百家求，一马不行百马忧。有花方酌酒，无月不登楼。三杯通大道，一醉解千愁。深山毕竟藏猛虎，大海终须纳细流。惜花须检点，爱月不梳头。大抵选她肌骨好，不搽红粉也风流。受恩深处宜先退，得意浓时便可休。莫待是非来入耳，从前恩爱反为仇。留得五湖明月在，不愁无处下金钩。休别有鱼处，莫恋浅滩头。去时终须去，再三留不住。忍一句，息一怒，饶一着，退一步。三十不豪，四十不富，五十将衰寻子助。生不认魂，死不认尸。一寸光阴一寸金，寸金难买寸光阴。黑发不知勤学早，转眼便是白头翁。父母恩深终有别，夫妻义重也分离。人生似鸟同林宿，大难来时各自飞。人善被人欺，马善被人骑。人无横财不富，马无夜草不肥。人恶人怕天不怕，人善人欺天不欺。善恶到头终有报，只盼来早与来迟。黄河尚有澄清日，岂能人无得运时？得宠思辱，居安思危。念念有如临敌日，心心常似过桥时。英雄行险道，富贵似花枝。人情莫道春光好，只怕秋来有冷时。送君千里，终有一别。但将冷眼观螃蟹，看你横行到几时。见事莫说，问事不知。闲事莫管，无事早归。假缎染就真红色，也被旁人说是非。善事可做，恶事莫为。许人一物，千金不移。龙生龙子，虎生虎儿。龙游浅水遭虾戏，虎落平阳被犬欺。一举首登龙虎榜，十年身到凤凰池。十年寒窗无人问，一举成名天下知。酒债寻常处处有，人生七十古来稀！养儿防老，积谷防饥。鸡豚狗彘之畜，无失其时，数口之家，可以无饥矣。当家才知盐米贵，养子方知父母恩。常将有日思无日，莫把无时当有时。树欲静而风不止，子欲养而亲不待。时来风送滕王阁，运去雷轰荐福碑。入门休问荣枯事，且看容颜便得知。官清司吏瘦，神灵庙祝肥。息却雷霆之怒，罢却虎豹之威。饶人算之本，输人算之机。好言难得，恶语易施。一言既出，驷马难追。道吾好者是吾贼，道吾恶者是吾师。路逢侠客须呈剑，不是才人莫献诗。三人同行，必有我师。择其善者而从之，其不善者而改之。欲昌和顺须为善，要振家声在读书。少壮不努力，老大徒伤悲。人有善愿，天必佑之。莫饮卯时酒，昏昏醉到酉。莫骂酉时妻，一夜受孤凄。种麻得麻，种豆得豆。天眼恢恢，疏而不漏。做官莫向前，作客莫在后。宁添一斗，莫添一口。螳螂捕蝉，岂知黄雀在后？不求金玉重重贵，但愿儿孙个个贤。一日夫妻，百世姻缘。百世修来同船渡，千世修来共枕眠。杀人一万，自损三千。伤人一语，利如刀割。枯木逢春犹再发，人无两度再少年。未晚先投宿，鸡鸣早看天。将相顶头堪走马，公侯肚内好撑船。富人思来年，穷人想眼前。世上若要人情好，赊去物品莫取钱。生死有命，富贵在天。击石原有火，不击乃无烟。人学始知道，不学亦徒然。莫笑他人老，终须还到老。和得邻里好，犹如拾片宝。但能守本分，终身无烦恼。大家做事寻常，小家做事慌张。大家礼义教子弟，小家凶恶训儿郎。君子爱财，取之有道。贞妇爱色，纳之以礼。善有善报，恶有恶报。不是不报，时候未到。万恶淫为首，百善孝当先。人而无信，不知其可也。一人道虚，千人传实。凡事要好，须问三老。若争小利，便失大道。家中不和邻里欺，邻里不和说是非。年年防饥，夜夜防盗。学者是好，不学不好。学者如禾如稻，不学如草如蒿。遇饮酒时须防醉，得高歌处且高歌。因风吹火，用力不多。不因渔夫引，怎能见波涛？无求到处人情好，不饮任他酒价高。知事少时烦恼少，识人多处是非多。世间好语书说尽，天下名山僧占多。进山不怕伤人虎，只怕人情两面刀。强中更有强中手，恶人须用恶人磨。会使不在家富豪，风流不用衣着多。光阴似箭，日月如梭。天时不如地利，地利不如人和。黄金未为贵，安乐值钱多。为善最乐，作恶难逃。羊有跪乳之恩，鸦有反哺之情。孝顺还生孝顺子，忤逆还生忤逆儿。不信但看檐前水，点点滴滴旧池窝。隐恶扬善，执其两端。妻贤夫祸少，子孝父心宽。已覆之水，收之实难。人生知足时常足，人老偷闲且是闲。处处绿杨堪系马，家家有路通长安。既坠釜甑，反顾无益。见者易，学者难。莫将容易得，便作等闲看。厌静还思喧，嫌喧又忆山。自从心定后，无处不安然。用心计较般般错，退后思量事事宽。道路各别，养家一般。由俭入奢易，从奢入俭难。知音说与知音听，不是知音莫与谈。点石化为金，人心犹未足。信了赌，卖了屋。他人观花，不涉你目。他人碌碌，不涉你足。谁人不爱子孙贤，谁人不爱千钟粟。奈五行，不是这般题目。莫把真心空计较，儿孙自有儿孙福。书到用时方恨少，事非经过不知难。天下无不是的父母，世上最难得者兄弟。与人不和，劝人养鹅；与人不睦，劝人架屋。但行好事，莫问前程。不交僧道，便是好人。河狭水激，人急计生。明知山有虎，莫向虎山行。路不铲不平，事不为不成。无钱方断酒，临老始读经。点塔七层，不如暗处一灯。堂上二老是活佛，何用灵山朝世尊。万事劝人休瞒昧，举头三尺有神明。但存方寸土，留与子孙耕。灭却心头火，剔起佛前灯。惺惺多不足，蒙蒙作公卿。众星朗朗，不如孤月独明。兄弟相害，不如友生。合理可作，小利不争。牡丹花好空入目，枣花虽小结实多。欺老莫欺小，欺人心不明。勤奋耕锄收地利，他时饱暖谢苍天。得忍且忍，得耐且耐，不忍不耐，小事成灾。相论逞英豪，家计渐渐退。贤妇令夫贵，恶妇令夫败。一人有庆，兆民咸赖。人老心未老，人穷志莫穷。人无千日好，花无百日红。黄蜂一口针，橘子两边分。世间痛恨事，最毒淫妇心。杀人可恕，情理不容。乍富不知新受用，乍贫难改旧家风。座上客常满，杯中酒不空。屋漏更遭连夜雨，行船又遇打头风。笋因落箨方成竹，鱼为奔波始化龙。记得少年骑竹马，转眼又是白头翁。礼义生于富足，盗贼出于赌博。天上众星皆拱北，世间无水不朝东。士为知己者死，女为悦己者容。色即是空，空即是色。君子安贫，达人知命。良药苦口利于病，忠言逆耳利于行。顺天者昌，逆天者亡。有缘千里来相会，无缘对面不相逢。有福者昌，无福者亡。人为财死，鸟为食亡。夫妻相和好，琴瑟与笙簧。红粉易妆娇态女，无钱难作好儿郎。有子之人贫不久，无儿无女富不长。善必寿老，恶必早亡。爽口食多偏作病，快心事过恐遭殃。富贵定要依本分，贫穷不必再思量。画水无风空作浪，绣花虽好不闻香。贪他一斗米，失却半年粮。争他一脚豚，反失一肘羊。龙归晚洞云犹湿，麝过春山草木香。平生只会说人短，何不回头把己量？见善如不及，见恶如探汤。人穷志短，马瘦毛长。自家心里急，他人未知忙。贫无达士将金赠，病有高人说药方。触来莫与竞，事过心清凉。秋来满山多秀色，春来无处不花香。凡人不可貌相，海水不可斗量。清清之水为土所防，济济之士为酒所伤。蒿草之下或有兰香，茅茨之屋或有侯王。无限朱门生饿殍，几多白屋出公卿。酒里乾坤大，壶中日月长。拂石坐来春衫冷，踏花归去马蹄香。万事前身定，浮生空自忙。叫月子规喉舌冷，宿花蝴蝶梦魂香。一言不中，千言不用。一人传虚，百人传实。万金良药，不如无疾。千里送鹅毛，礼轻情义重。世事如明镜，前程暗似漆。君子怀刑，小人怀惠。架上碗儿轮流转，媳妇自有做婆时。人生一世，如驹过隙。良田万顷，日食一升。大厦千间，夜眠八尺。千经万典，孝义为先。天上人间，方便第一。一字入公门，九牛拔不出。八字衙门向南开，有理无钱莫进来。欲求天下事，须用世间财。富从升合起，贫因不算来。近河不得枉使水，近山不得枉烧柴。家无读书子，官从何处来？慈不掌兵，义不掌财。一夫当关，万夫莫开。万事不由人计较，一生都是命安排。白云本是无心物，却被清风引出来。慢行急行，逆取顺取。命中只有如许财，丝毫不可有闪失。人间私语，天闻若雷。暗室亏心，神目如电。一毫之恶，劝人莫作。一毫之善，与人方便。亏人是祸，饶人是福，天眼恢恢，报应甚速。圣贤言语，神钦鬼服。人各有心，心各有见。口说不如身逢，耳闻不如目见。见人富贵生欢喜，莫把心头似火烧。养兵千日，用在一时。国清才子贵，家富小儿娇。利刀割体疮犹使，恶语伤人恨不消。公道世间唯白发，贵人头上不曾饶。有才堪出众，无衣懒出门。为官须作相，及第必争先。苗从地发，树由枝分。宅里燃火，烟气成云。以直报怨，知恩报恩。红颜今日虽欺我，白发他时不放君。借问酒家何处有，牧童遥指杏花村。父子和而家不退，兄弟和而家不分。一片云间不相识，三千里外却逢君。官有公法，民有私约。平时不烧香，临时抱佛脚。幸生太平无事日，恐防年老不多时。国乱思良将，家贫思良妻。池塘积水须防旱，田地深耕足养家。根深不怕风摇动，树正何愁月影斜。争得猫儿，失却牛脚。愚者千虑，必有一得，智者千虑，必有一失。始吾于人也，听其言而信其行。今吾于人也，听其言而观其行。哪个梳头无乱发，情人眼里出西施。珠沉渊而川媚，玉韫石而山辉。夕阳无限好，只恐不多时。久旱逢甘霖，他乡遇故知；洞房花烛夜，金榜题名时。惜花春起早，爱月夜眠迟。掬水月在手，弄花香满衣。桃红李白蔷薇紫，问着东君总不知。教子教孙须教义，栽桑栽柘少栽花。休念故乡生处好，受恩深处便为家。学在一人之下，用在万人之上。一日为师，终生为父。忘恩负义，禽兽之徒。劝君莫将油炒菜，留与儿孙夜读书。书中自有千钟粟，书中自有颜如玉。莫怨天来莫怨人，五行八字命生成。莫怨自己穷，穷要穷得干净；莫羡他人富，富要富得清高。别人骑马我骑驴，仔细思量我不如，待我回头看，还有挑脚汉。路上有饥人，家中有剩饭。积德与儿孙，要广行方便。作善鬼神钦，作恶遭天遣。积钱积谷不如积德，买田买地不如买书。一日春工十日粮，十日春工半年粮。疏懒人没吃，勤俭粮满仓。人亲财不亲，财利要分清。十分伶俐使七分，常留三分与儿孙，若要十分都使尽，远在儿孙近在身。君子乐得做君子，小人枉自做小人。好学者则庶民之子为公卿，不好学者则公卿之子为庶民。惜钱莫教子，护短莫从师。记得旧文章，便是新举子。人在家中坐，祸从天上落。但求心无愧，不怕有后灾。只有和气去迎人，哪有相打得太平。忠厚自有忠厚报，豪强一定受官刑。人到公门正好修，留些阴德在后头。为人何必争高下，一旦无命万事休。山高不算高，人心比天高。白水变酒卖，还嫌猪无糟。贫寒休要怨，宝贵不须骄。善恶随人作，祸福自己招。奉劝君子，各宜守己。只此呈示，万无一失。 下集前人俗语，言浅理深。补遗增广，集成书文。世上无难事，只怕不专心。成人不自在，自在不成人；金凭火炼方知色，与人交财便知心。乞丐无粮，懒惰而成。勤俭为无价之宝，节粮乃众妙之门。省事俭用，免得求人。量大祸不在，机深祸亦深。善为至宝深深用，心作良田世世耕。群居防口，独坐防心。体无病为富贵，身平安莫怨贫。败家子弟挥金如土，贫家子弟积土成金。富贵非关天地，祸福不是鬼神。安分贫一时，本分终不贫。不拜父母拜干亲，弟兄不和结外人。人过留名，雁过留声。择子莫择父，择亲莫择邻。爱妻之心是主，爱子之心是亲。事从根起，藕叶连心。祸与福同门，利与害同城。清酒红人脸，财帛动人心！宁可荤口念佛，不可素口骂人。有钱能说话，无钱话不灵。岂能尽如人意？但求不愧吾心。不说自己井绳短，反说他人箍井深。恩爱多生病，无钱便觉贫。只学斟酒意，莫学下棋心。孝莫假意，转眼便为人父母。善休望报，回头只看汝儿孙！口开神气散，舌出是非生！弹琴费指甲，说话费精神。千贯买田，万贯结邻。人言未必犹尽，听话只听三分。隔壁岂无耳，窗外岂无人？财可养生须注意，事不关己不劳心。酒不护贤，色不护病；财不护亲，气不护命！一日不可无常业，安闲便易起邪心！炎凉世态，富贵更甚于贫贱；嫉妒人心，骨肉更甚于外人！瓜熟蒂落，水到渠成。人情送匹马，买卖不饶针！过头饭好吃，过头话难听！事多累了自己，田多养了众人。怕事忍事不生事自然无事；平心静心不欺心何等放心！天子至尊不过于理，在理良心天下通行。好话不在多说，有理不在高声！一朝权在手，便把令来行。甘草味甜人可食，巧言妄语不可听。当场不论，过后枉然。贫莫与富斗，富莫与官争！官清难逃猾吏手，衙门少有念佛人！家有千口，主事一人。父子竭力山成玉，弟兄同心土变金。当事者迷，旁观者清。怪人不知理，知理不怪人。未富先富终不富，未贫先贫终不贫。少当少取，少输当赢！饱暖思淫欲，饥寒起盗心！蚊虫遭扇打，只因嘴伤人！欲多伤神，财多累心！布衣得暖真为福，千金平安即是春。家贫出孝子，国乱显忠臣！宁做太平犬，莫做离乱人！人有几等，官有几品。理不卫亲，法不为民。自重者然后人重，人轻者便是自轻。自身不谨，扰乱四邻。快意事过非快意，自古败名因败事。伤身事莫做，伤心话莫说。小人肥口，君子肥身。地不生无名之辈，天不生无路之人。一苗露水一苗草，一朝天子一朝臣。读未见书如逢良友，见已读书如逢故人。福满须防有祸，凶多料必无争。不怕三十而死，只怕死后无名。但知江湖者，都是薄命人。不怕方中打死人，只知方中无好人。说长说短，宁说人长莫说短；施恩施怨，宁施人恩莫施怨。育林养虎，虎大伤人。冤家抱头死，事要解交人。卷帘归乳燕，开扇出苍蝇。爱鼠常留饭，怜蛾灯罩纱。人命在天，物命在人。奸不通父母，贼不通地邻。盗贼多出赌博，人命常出奸情。治国信谗必杀忠臣，治家信谗必疏其亲。治国不用佞臣，治家不用佞妇。好臣一国之宝，好妇一家之珍。稳的不滚，滚的不稳。儿不嫌母丑，狗不嫌家贫。君子千钱不计较，小人一钱恼人心。人前显贵，闹里夺争。要知江湖深，一个不做声。知止自当出妄想，安贫须是禁奢心。初入行业，三年事成；初吃馒头，三年口生。家无生活计，坐吃如山崩。家有良田万顷，不如薄艺在身；艺多不养家，食多嚼不赢。命中只有八合米，走遍天下不满升。使心用心，反害自身。国家无空地，世上无闲人。妙药难医怨逆病，混财不富穷命人。耽误一年春，十年补不清；人能处处能，草能处处生。会打三班鼓，也要几个人。人不走不亲，水不打不浑。三贫三富不到老，十年兴败多少人！买货买得真，折本折得轻；不怕问到，只怕倒问。人强不如货强，价高不如口便。会买买怕人，会卖卖怕人。只只船上有梢公，天子足下有贫亲。既知莫望，不知莫向。在一行，练一行；穷莫失志，富莫癫狂。天欲令其灭亡，必先让其疯狂。梢长人胆大，梢短人心慌。隔行莫贪利，久炼必成钢。瓶花虽好艳，相看不耐长。早起三光，迟起三慌。未来休指望，过去莫思量；时来遇好友，病去遇良方。布得春风有夏雨，哈得秋风大家凉。晴带雨伞，饱带饥粮。满壶全不响，半壶响叮当。久利之事莫为，众争之地莫往。老医迷旧疾，朽药误良方；该在水中死，不在岸上亡。舍财不如少取，施药不如传方。倒了城墙丑了县官，打了梅香丑了姑娘。燕子不进愁门，耗子不钻空仓。苍蝇不叮无缝蛋，谣言不找谨慎人。一人舍死，万人难当。人争一口气，佛争一炷香。门为小人而设，锁乃君子之防。舌咬只为揉，齿落皆因眶。硬弩弦先断，钢刀刃自伤。贼名难受，龟名难当。好事他人未见讲，错处他偏说得长。男子无志纯铁无钢，女子无志烂草无瓤。生男欲得成龙犹恐成獐，生女欲得成凤犹恐成虎。养男莫听狂言，养女莫叫离母。男子失教必愚顽，女子失教定粗鲁。生男莫教弓与弩，生女莫教歌与舞。学成弓弩沙场灾，学成歌舞为人妾。财交者密，财尽者疏。婚姻论财，夫妻之道。色娇者亲，色衰者疏。少实胜虚，巧不如拙。百战百胜不如无争，万言万中不如一默。有钱不置怨逆产，冤家宜解不宜结。近朱者赤，近墨者黑。一个山头一只虎，恶龙难斗地头蛇。出门看天色，进门看脸色。商贾买卖如施舍，买卖公平如积德。天生一人，地生一穴。家无三年之积不成其家，国无九年之积不成其国。男子有德便是才，女子无才便是德。有钱难买子孙贤，女儿不请上门客。男大当婚女大当嫁，不婚不嫁惹出笑话。谦虚美德，过谦即诈。自己跌倒自己爬，望人扶持都是假。人不知己过，牛不知力大。一家饱暖千家怨，一物不见赖千家。当面论人惹恨最大，是与不是随他说吧！谁人做得千年主，转眼流传八百家。满载芝麻都漏了，还在水里捞油花！皇帝坐北京，以理统天下。五百年前共一家，不同祖宗也同华！学堂大如官厅，人情大过王法。找钱犹如针挑土，用钱犹如水推沙！害人之心不可有，防人之心不可无！不愁无路，就怕不做。须向根头寻活计，莫从体面下功夫！祸从口出，病从口入。药补不如肉补，肉补不如养补。思虑之害甚于酒色，日日劳力上床呼疾。人怕不是福，人欺不是辱。能言不是真君子，善处方为大丈夫！为人莫犯法，犯法身无主。姊妹同肝胆，弟兄同骨肉。慈母多误子，悍妇必欺夫！君子千里同舟，小人隔墙易宿。文钱逼死英雄汉，财不归身恰是无。妻子如衣服，弟兄似手足。衣服补易新，手足断难续。盗贼怨失主，不孝怨父母。一时劝人以口，百世劝人以书。我不如人我无其福，人不如我我常知足！捡金不忘失金人，三两黄铜四两福。因祸得福，求赌必输。一言而让他人之祸，一忿而折平生之福。天有不测风云，人有旦夕祸福。不淫当斋，淡饱当肉。缓步当车，无祸当福。男无良友不知己之有过，女无明镜不知面之精粗。事非亲做，不知难处。十年易读举子，百年难淘江湖！积钱不如积德，闲坐不如看书。思量挑担苦，空手做是福。时来易借银千两，运去难赊酒半壶。天晴打过落雨铺，少时享过老来福。与人方便自己方便，一家打墙两家好看。当面留一线，过后好相见。入门掠虎易，开口告人难。手指要往内撇，家丑不可外传。浪子出于祖无德，孝子出于前人贤。货离乡贵，人离乡贱。树挪死，人挪活。在家千日好，出门处处难。三员长者当官员，几个明人当知县？明人自断，愚人官断。人怕三见面，树怕一墨线。村夫硬似铁，光棍软如棉。不是撑船手，怎敢拿篙竿！天下礼仪无穷，一人知识有限。一人不得二人计，宋江难结万人缘。家有三亩田，不离衙门前，乡间无强汉，衙门就饿饭。人人依礼仪，天下不设官。衙门钱，眼睛钱；田禾钱，千万年。诗书必读，不可做官。为人莫当官，当官皆一般。换了你我去，恐比他还贪。官吏清廉如修行，书差方便如行善。靠山吃山，种田吃田。吃尽美味还是盐，穿尽绫罗还是棉。一夫不耕，全家饿饭，一女不织，全家受寒。金银到手非容易，用时方知来时难。先讲断，后不乱，免得藕断丝不断。听人劝，得一半。不怕慢，只怕站。逢快莫赶，逢贱莫懒。谋事在人，成事在天！长路人挑担，短路人赚钱。宁卖现二，莫卖赊三。赚钱往前算，折本往后算。小小生意赚大钱，七十二行出状元。自己无运至，却怨世界难。胆大不如胆小，心宽甚如屋宽。妻贤何愁家不富，子孙何须受祖田。是儿不死，是财不散。财来生我易，我去生财难。十月滩头坐，一日下九滩。结交一人难上难，得罪一人一时间。借债经商，卖田还债；赊钱起屋，卖屋还钱。修起庙来鬼都老，拾得秤来姜卖完。不嫖莫转，不赌莫看。节食以去病，少食以延年。豆腐多了是包水，梢公多了打烂船。无口过是，无眼过难。无身过易，无心过难。不会凫水怨河湾，不会犁田怨枷担。他马莫骑，他弓莫挽。要知心腹事，但听口中言。宁在人前全不会，莫在人前会不全。事非亲见，切莫乱谈。打人莫打脸，骂人莫骂短。好言一句三冬暖，话不投机六月寒。人上十口难盘，帐上万元难还。放债如施，收债如讨。告状讨钱，海底摸盐。衙门深似海，弊病大如天。银钱莫欺骗，牛马不好变。好汉莫被人识破，看破不值半文钱。狗咬对头人，雷打三世冤。不卖香烧无剩钱，井水不打不满边。事宽则园，太久则偏。高人求低易，低人求高难。有钱就是男子汉，无钱就是汉子难。人上一百，手艺齐全。难者不会，会者不难。生就木头造就船，砍的没得车的圆。心不得满，事不得全。鸟飞不尽，话说不完。人无喜色休开店，事不遂心莫怨天。选婿莫选田园，选女莫选嫁奁。红颜女子多薄命，福人出在丑人边。人将礼义为先，树将花果为园。临危许行善，过后心又变。天意违可以人回，命早定可以心挽。强盗口内出赦书，君子口中无戏言。贵人语少，贫子话多。快里须斟酌，耽误莫迟春。读过古华佗，不如见症多。东屋未补西屋破，前帐未还后又拖。今年又说明年富，待到明年差不多。志不同己，不必强合。莫道坐中安乐少，须知世上苦情多。本少利微强如坐，屋檐水也滴得多。勤俭持家富，谦恭受益多。细处不断粗处断，黄梅不落青梅落。见钱起意便是贼，顺手牵羊乃为盗。要做快活人，切莫寻烦恼。要做长寿人，莫做短命事。要做有后人，莫做无后事。不经一事，不长一智。宁可无钱使，不可无行止。栽树要栽松柏，结交要结君子。秀才不出门，能知天下事。钱多不经用，儿多不耐死。弟兄争财家不穷不止，妻妾争风夫不死不止。男人有志，妇人有势。夫人死百将临门，将军死一卒不至。天旱误甲子，人穷误口齿。百岁无多日，光阴能几时？父母养其身，自己立其志。待有余而济人，终无济人之日；待有闲而读书，终无读书之时。此书传后世，句句必精读，其中礼和义，奉劝告世人。勤奋读，苦发奋，走遍天涯如游刃。 新增广贤文尊师以重道，爱众而亲仁。钱财如粪土，仁义值千金。作事须循天理，出言要顺人心。处富贵地，要矜持贫贱的痛痒，当少壮时，须体念衰老的辛酸。孝当竭力，非徒养身。鸦有反哺之孝，羊知跪乳之恩。打虎还要亲兄弟，出阵还须父子兵。父子和而家不败，弟兄和而家不分。知己知彼，将心比心。责人之心责己，爱己之心爱人。贪爱沉溺即苦海，利欲炽燃是火坑。随时莫起趋时念，脱俗休存矫俗心。昼夜惜阴，夜坐惜灯。读书须用意，一字值千金。平生不作皱眉事，世上应无切齿人。近水知鱼性，近山识鸟音。路遥知马力，日久见人心。饶人不是痴汉，痴汉不会饶人。不说自己桶索短，但怨人家箍井深。美不美，乡中水；亲不亲，故乡人。割不断的亲，离不开的邻。但行好事，莫问前程。钝鸟先飞，大器晚成。一年之计在于春，一日之计在于寅。一家之计在于和，一生之计在于勤。无病休嫌瘦，身安莫怨贫。岂能尽如人意，但求无愧人心。偏听则暗，兼听则明。耳闻是虚，眼见是实。毋施小惠而伤大体，毋借公论而快私情。毋以已长而形人之短，毋因已拙而忌人之能。平日不作亏心事，半夜敲门心不惊。牡丹花好空入目，枣花虽小结实成。汝惟不矜，天下莫与汝争能；汝惟不伐，天下莫与汝争功。明不伤察，直不过矫。仁能善断，清能有容。不自是而露才，不轻试以幸功。受享不逾分外，修持不减分中。肝肠煦若春风，虽囊乏一文，还怜茕独；气骨清如秋水，纵家徒四壁，终傲王公。早把甘旨勤奉养，夕阳光阴不多时。得宠思辱，居安思危。成名每在穷苦日，败事多因得意时。许人一物，千金不移。一言既出，驷马难追。博学而笃志，切问而近思。惜钱休教子，护短莫从师。须知孺子可教，勿谓童子何知。静坐常思已过，闲谈莫论人非。三人同行，必有我师，择其善者而从，其不善者改之。狎昵恶少，久必受其累；屈志老成，急则可相依。心口如一，童叟无欺。人有善念，天必佑之。过则无惮改，独则毋自欺。道吾好者是吾贼，道吾恶者是吉师。学不尚行，马牛而襟裾。结交须胜已，似我不如无。同君一席话，胜读十年书。水至清，则无鱼；人至察，则无徒。宁可正而不足，不可斜而有余。认真还自在，作假费功夫。是非朝朝有，不听自然无。聪明逞尽，惹祸招灾。富从升合起，贫因不算来。用人不宜刻，刻则思效者去；交友不宜滥，滥则贡谀者来。乐不可极，乐极生哀；欲不可纵，纵欲成灾。言顾行，行顾言。不作风波于世上，但留清白在人间。勿因群疑而阻独见，勿任已意而废人言。自处超然，处人蔼然。得意淡然，失意泰然。由俭入奢易，由奢入俭难。枯木逢春犹再发，人无两度再少年。儿孙胜于我，要钱做甚么；儿孙不如我，要钱做甚么。谦恭待人，忠厚传家。不学无术，读书便佳。与治同道罔不兴，与乱同事罔不亡。居身务期质朴，训子要有义方。富若不教子，钱谷必消灭。贵若不教子，衣冠受不长。人无远虑，必有近忧。勿临渴而掘井，宜未雨而绸缪。酒虽痒性还乱性，水能载舟亦覆舟。克已者，触事皆成药石；尤人者，启口即是戈矛。儿孙自有儿孙福，莫与儿孙做牛马。深山毕竟藏猛虎，大海终须纳细流。休向君子诌媚，君子原无私惠；休与小人为仇，小人自我对头。登高必自卑，若涉远必自迩。磨刀恨不利，刀利伤人指；求财恨不多，财多终累已。居视其所亲，达视其所举；富视其所不为，贫视其所不取。知足常足，终身不辱；知止常止，终身不耻。君子爱财，取之有道；小人放利，不顾天理。悖入亦悖出，害人终害已。身欲出樊笼外，心要在腔子里。勿偏信而为奸所欺，勿自任而为气所使。使口不如自走，求人不如求已。处骨肉之变，宜从容不宜激烈；当家庭之衰，宜惕厉不宜委靡。务下学而上达，毋舍近而趋远。量入为出，凑少成多。溪壑易填，人心难满。用人与教人，二者却相反，用人取其长，教人责其短。仕宦芳规清、慎、勤，饮食要诀缓、暖、软。留心学到古人难，立脚怕随流俗转。凡是自是，便少一是。有短护短，更添一短。好问则裕，自用则小。勿营华屋，勿作营巧。若争小可，便失大道。但能依本分，终须无烦恼。有言逆于汝心，必求诸道；有言逊于汝志，必求诸非道。吃得亏，坐一堆；要得好，大做小。志宜高而身宜下，胆欲大而心欲小。学者如禾如稻，不学者如蒿如草。唇亡齿必寒，教弛富难保。书中结良友，千载奇逢；门内产贤郎，一家活宝。狗不嫌家贫，儿不嫌母丑。勿贪意外之财，勿饮过量之酒。进步便思退步，着手先图放手。责善勿过高，当思其可从。攻恶勿太严，要使其可受。和气致祥，乖气致戾。玩人丧德，玩物丧志。门内有君子，门外君子至；门内有小人，门外小人至。趋炎虽暖，暖后更觉寒增；食蔗能甘，甘余更生苦趣。家庭和睦，蔬食尽有余欢；骨肉乖违，珍馐亦减至味。先学耐烦，切莫使气。性躁心粗，一生不济。得时莫夸能，不遇休妒世。物盛则必衰，有隆还有替。路径仄处，留一步与人行；滋味浓时，减三分让人嗜。为人要学大莫学小，志气一卑污了，品格难乎其高；持家要学小莫学大，门面一 弄阔了，后来难乎其继。三十不立，四十见恶，五十相将寻死路。见怪不怪，怪乃自败。一正压百邪，少见必多怪。君子之交淡以成，小人之交甘以坏。爱人者，人恒爱。敬人者，人恒敬。损友敬而远，益友亲而敬。善与人交，久而能敬。过则相规，言而有信。木受绳则直，人受柬则圣。良药苦口利于病，忠言逆耳利于行。智生识，识生断。当断不断，反受其乱。一毫之恶，劝人莫作；一毫之善，与人方便。难合亦难分，易亲亦易散。传家二字耕与读，防家二字盗与奸，倾家二字淫与赌，守家二字勤与俭。不汲汲于富贵，不戚戚于贫贱。素位而行，不尤不怨。先达之人可尊也，不可比媚。权势之人可远也，不可侮慢。善有善报，恶有恶报，若有不报，日子未到。贤者不炫已之长，君子不夺人所好。救既败之事，如驭临岩之马，休轻加一鞭；图垂成之功，如挽上滩之舟，莫稍停一棹。大事不糊涂，小事不渗漏。内藏精明，外示浑厚。恩宜先淡而浓，先浓后淡者，人忘其惠；威宜自严而宽，先宽后严者，人怨其酷。以积货财之心积学问，则盛德日新；以爱妻子之心爱父母，则孝行自笃。学须静，才须学。非学无以广才，非静无以成学。不患老而无成，只怕幼而不学。富贵如刀兵戈矛，稍放纵便销膏靡骨而不知；贫贱如针砭药石，一忧勤即砥节砺行而不觉。不矜细行，终累大德。亲戚不悦，无务外交；事不终始，无务多业。民为邦本，本固邦宁。安居饱食，天下太平。临难勿苟免，临财勿苟得。谗言不可听，听之祸殃结。君听臣遭诛，父听子遭灭，夫妇听之离，兄弟听之别，朋友听之疏，亲戚听之绝。性天澄澈，即饥餐渴饮，无非康济身肠；心地沉迷，纵演偈谈玄，总是播弄精魄。芝兰生于深林，不以无人而不芳；君子修其道德，不为穷困而改节。廉官可酌贪泉水，志士不受嗟来食。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>增关贤文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扇贝-每日一句]]></title>
    <url>%2Fapi-quote.html</url>
    <content type="text"><![CDATA[前言偶然看到某个小伙伴的博客（https://alili.tech/ ）有查询扇贝的每日一句，加上打字效果，让我感觉很新奇。所以扒了下扇贝的每日一句接口，放到自己的服务器上，后续集成到自己的博客里面。API共分为几个接口， 第一个接口是直接获取当天的每日一句，返回的字段较多，有些字段并未标注什么含义，也没有什么作用； 第二个接口是查询历史的每日一句，因为本服务是从2019-01-12开始提供的，所以历史的数据是比较简单的结构。当然2019-01-12开始的每日一句都保存了下来，再查询就和第一种接口的数据是一致的了。 第三个接口是随机查询历史的每日一句。 你也可以通过Spring Cloud进行调用，我使用程序员DD的注册中心：http://eureka.didispace.com/应用名称：QUOTE-API 使用中存在任何问题，可通过邮箱tecchen@aliyun.com联系我~（ 如果侵权，请联系我删除 ） 另外还有个天气预报的API（应用名称：WEATHER-API）还在开发中，敬请关注~ 接口文档每日一句 请求地址 http://api.tecchen.xyz/api/quote/ 请求方式 GET 请求参数示例 无 请求参数说明 无 返回参数示例 123456789101112131415161718192021222324252627282930313233&#123; "code": 0, "message": "成功", "data": &#123; "id": "ihscc", "author": "Juvenal", "content": "Never does nature say one thing and wisdom another.", "assignDate": "2019-01-19", "adUrl": "https://h10.shanbay.com/s/track?st=s&amp;url=https%3A%2F%2Fwww.shanbay.com%2Fweb%2Fplan365%2F&amp;ct=transformer&amp;x_data=%7B%22_%22%3A+%228d58fd%22%7D&amp;x_cdata=%7B%22campaign_code%22%3A+%22kc98hu5tv%22%7D", "shareUrl": "https://www.shanbay.com/soup/mobile/quote/2019-01-19/", "shareUrls": &#123; "weibo": "https://www.shanbay.com/soup/mobile/quote/2019-01-19/", "shanbay": "https://www.shanbay.com/soup/mobile/quote/2019-01-19/", "wechat": "https://www.shanbay.com/soup/mobile/quote/2019-01-19/", "qzone": "https://www.shanbay.com/soup/mobile/quote/2019-01-19/", "wechat_user": "https://www.shanbay.com/soup/mobile/quote/2019-01-19/" &#125;, "trackObject": &#123; "code": "abb22", "share_url": "https://www.shanbay.com/soup/mobile/quote/2019-01-19/", "object_id": 2485 &#125;, "translation": "自然与智慧永不相悖。", "originImgUrls": [ "https://media-image1.baydn.com/soup_pub_image/ccdbwr/fd3e0cb49ece0faeab0ec1126dab342f.aaf209e859f6598d50ec3d3593e6596b.png@!fhd_webp", "https://media-image1.qiniu.baydn.com/soup_pub_image/ccdbwr/fd3e0cb49ece0faeab0ec1126dab342f.aaf209e859f6598d50ec3d3593e6596b.png?imageView2/2/w/1080/format/webp" ], "shareImgUrls": [ "https://media-image1.baydn.com/soup_pub_image/ccdbwr/61fcabc6631b1deac4804fcb84739ba2.3a1761e8ed5c49723ee6040d390fe416.png@!w720", "https://media-image1.qiniu.baydn.com/soup_pub_image/ccdbwr/61fcabc6631b1deac4804fcb84739ba2.3a1761e8ed5c49723ee6040d390fe416.png?imageView2/2/w/720/" ] &#125;&#125; 返回参数说明 参数名称 类型 说明 备注 author string 作者/出处 content string 摘录 assignDate string 日期 translation string 翻译 originImgUrls Array 原始图片链接 不包含摘录 shareImgUrls Array 分享图片链接 包含摘录 扇贝- 历史 - 每日一句获取指定日期（格式：yyyy-MM-dd）的每日一句 请求地址 http://api.tecchen.xyz/api/quote/{requestDate}/ 请求方式 GET 请求参数示例 http://api.tecchen.xyz/api/quote/2019-11-11/ 请求参数说明 参数名称 类型 说明 备注 requestDate string 日期 格式：yyyy-MM-dd 返回参数示例 12345678910111213141516171819&#123; "code": 0, "message": "成功", "data": &#123; "id": null, "author": "约翰·梅纳德·凯恩斯", "content": "Ideas shape the course of history.", "assignDate": "2019-01-11", "adUrl": null, "shareUrl": null, "shareUrls": null, "trackObject": null, "translation": "想法影响着历史进程。", "originImgUrls": [ "https://media-image1.baydn.com/soup_pub_image/ccdbwr/312d1addd474109097d8be4ceaf44d4c.88972797e32da926072b61a867ea17eb.png?x-oss-process=image/format,jpg" ], "shareImgUrls": null &#125;&#125; 返回参数说明 参数名称 类型 说明 备注 author string 作者/出处 content string 摘录 assignDate string 日期 translation string 翻译 originImgUrls Array 原始图片链接 不包含摘录 随机获取一句历史的每日一句随机获取一句历史的每日一句，可以用于博客首页，每次访问，内容都会变化，更吸引读者。 请求地址 http://api.tecchen.xyz/api/quote/history/random/ 请求方式 GET 请求参数示例 无 请求参数说明 无 返回参数示例 12345678910111213141516171819&#123; "code": 0, "message": "成功", "data": &#123; "id": null, "author": "Baltasar Gracian", "content": "A wise man gets more use from his enemies than a fool from his friends.", "assignDate": "2017-11-14", "adUrl": null, "shareUrl": null, "shareUrls": null, "trackObject": null, "translation": "智者从敌人身上学到的，多过愚者从朋友身上学到的。", "originImgUrls": [ "https://media-image1.baydn.com/soup_pub_image/qqnjfi/e50a1650c2a23de9526d8d6c4c30cf46.f707e8b26a5e5baa5b1cd32858ded05b.png?x-oss-process=image/format,jpg" ], "shareImgUrls": null &#125;&#125; 返回参数说明 参数名称 类型 说明 备注 author string 作者/出处 content string 摘录 assignDate string 日期 translation string 翻译 originImgUrls Array 原始图片链接 不包含摘录 HTTPS接口以上接口均支持HTTPS方式请求，请求地址为https://www.tecchen.xyz/api/~，只需要将HTTP改为HTTPS，将api改为www即可。 小彩蛋浏览器访问https://api.tecchen.xyz/quote.html发现小精彩哦～～～ 通用的返回报文格式 参数名称 类型 说明 备注 code int 编码 0:成功; 400:参数非法; 500:服务器错误;其他:请根据message确认 不是HTTP的请求状态码 message string 成功／错误信息 data object 数据 以json格式返回 更新记录v1.0.02019-01-13 扇贝每日一句 支持历史的每日一句 彩蛋页面 v1.0.12019-01-19 优化返回的json 优化定时任务获取日志逻辑 支持HTTPS 随机获取一句历史的每日一句 v1.0.22019-02-18 接入Spring cloud gateway 静态页面和动态请求分离 修复因框架升级造成的乱码问题 调整小彩蛋体验路径，优化移动端图片显示 未完待续……持续更新……感谢支持与打赏]]></content>
      <categories>
        <category>免费API</category>
      </categories>
      <tags>
        <tag>每日一句</tag>
        <tag>扇贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客系列(三)-利用GitLab Pages发布Hexo v3.x个人博客]]></title>
    <url>%2Fblog-hexo-env-03.html</url>
    <content type="text"><![CDATA[相关链接 GitLab Pages：https://about.gitlab.com/product/pages/ 前言这里不多说Git作为版本控制系统的优势，Gitlab作为支持私有仓库的开源Git系统，另外开放了Pages的功能，可以实现个人静态博客的部署及访问。 本文仅将Hexo打包后的代码提交到Gitlab，并利用CI/CD发布到Gitlab Pages，实现可以通过 https://username.gitlab.io/projectname 或者 https://username.gitlab.io 可以访问博客的目的。 创建仓库Gitlab支持project page和user page两种pages，只需要创建对应的仓库即可。如果想通过https://username.gitlab.io/projectname 形式访问，需要创建projectname的仓库。 如果想通过https://username.gitlab.io ，需要创建username.gitlab.io的仓库 代码发布修改站点配置文件，找到deploy配置，将type设置为git，并填写自己的repo地址，分支默认为master即可。1234deploy: type: git repo: git@gitlab.com:java4candy/java4candy.gitlab.io.git branch: master 执行hexo clean &amp;&amp; hexo d -g，即可将发布后的代码提交到Gitlab。 Gitlab 配置CI/CD新建文件方式：在Gitlab中，根据.gitlab-ci.yml模板New file并上传。 上传文件方式：选择Upload file，将本地的.gitlab-ci.yml文件上传到Gitlab。 文件内容：12345678910111213# This file is a template, and might need editing before it works on your project.# Full project: https://gitlab.com/pages/plain-htmlpages: stage: deploy script: - mkdir .public - cp -r * .public - mv .public public artifacts: paths: - public only: - master 上传后，Gitlab会自动校验.gitlab-ci.yml文件语法，校验通过后，自动执行。另外，在左边菜单CI/CD-&gt;Pipelines中能够查看Pipeline、对应的Jobs及脚本的执行情况。如果需要定时发布，可以使用Schedules创建Cron定时器。 最后在在Settings-&gt;Pages查看正确的的访问路径。 通过https://username.gitlab.io/projectname 或者 https://username.gitlab.io 访问博客。]]></content>
      <categories>
        <category>Hexo博客系列</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Gitlab Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客系列(二)-在多台机器上编写Hexo v3.x博客]]></title>
    <url>%2Fblog-hexo-env-02.html</url>
    <content type="text"><![CDATA[针对在公司及家里的电脑上都有编写博客的可能，或者多人同时维护一个独立博客的情况，需要在多台机器上配置环境好环境，然后将Git仓库中的博客更新下来，继续编写博客。个人是将博客托管在Gitee（码云）的仓库，将NexT主题托管在Github上的仓库。因为博客源码需要放在私有仓库（Github也已经开发私有仓库了，Gitlab本来就支持私有仓库），不开放出来，NexT主题是直接fork的NexT官方主题（https://github.com/theme-next/hexo-theme-next/ ），根据自己的需要进行修改保存。下面介绍已有博客仓库和主题仓库的情况下，如何在各台机器进行配置。 日常写博客正常情况下，仅仅需要到博客根路径和主题根路径，使用git pull拉取最新代码。 第一步：clone自己的hexo博客项目在想要新建的目录下（例如：D:\IdeaProjects）执行以下命令，创建目录hexo-blog并clone项目。 1git clone git@gitlab.com:java4candy/hexo-blog.git hexo-blog 第二步：clone自己的next主题项目在想要新建的目录下（例如：D:\IdeaProjects）执行以下命令，创建目录hexo-blog/themes/next并clone Next主题代码。 1git clone git@gitlab.com:java4candy/hexo-theme-next.git hexo-blog/themes/next 第三步：启动服务器 1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server 第四步：使用浏览器进行访问访问http://localhost:4000/ 即可。 初始化环境以下仅限在新机器上进行一次性操作。 第一步：clone自己的hexo博客项目 1git clone git@gitlab.com:java4candy/hexo-blog.git hexo-blog 第二步：clone自己的next主题项目 1git clone git@gitlab.com:java4candy/hexo-theme-next.git hexo-blog/themes/next 第三步：安装hexo使用淘宝镜像，安装依赖 1npm install --save --registry=https://registry.npm.taobao.org 该命令会根据package.json中的dependencies将依赖下载并安装到node_modules目录。可以使用npm ls -dept 0查看具体有哪些依赖。1234567891011121314+-- hexo@3.8.0+-- hexo-asset-image@0.0.3+-- hexo-deployer-git@0.3.1+-- hexo-generator-archive@0.1.5+-- hexo-generator-baidu-sitemap@0.1.6+-- hexo-generator-category@0.1.3+-- hexo-generator-index-pin-top@0.2.2+-- hexo-generator-sitemap@1.2.0+-- hexo-generator-tag@0.2.0+-- hexo-renderer-ejs@0.3.1+-- hexo-renderer-marked@0.3.2+-- hexo-renderer-stylus@0.3.3+-- hexo-server@0.3.3`-- hexo-symbols-count-time@0.4.4 【不要执行hexo init，其实执行后，也会提示文件夹不为空。】123FATAL D:\IdeaProjects\hexo-blog\ not empty, please run `hexo init` on an empty folder and then copy your files into itFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: target not empty 第四步：启动服务器使用hexo server或者简写hexo s启动服务器 1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server 第五步：使用浏览器进行访问访问http://localhost:4000/ 即可。]]></content>
      <categories>
        <category>Hexo博客系列</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客系列(一)-Windows系统配置Hexo v3.x个人博客环境]]></title>
    <url>%2Fblog-hexo-env-01.html</url>
    <content type="text"><![CDATA[相关链接 Hexo官网文档：https://hexo.io/zh-cn/docs/ Git官网：https://www.git-scm.com/ Pro Git：https://www.git-scm.com/book/zh/v2 环境安装 项目 版本 操作系统 Windows Git Git-2.20.1-x64 https://www.git-scm.com Node.js node-v11.6.0-x64 https://nodejs.org Hexo v3.8.0 https://hexo.io Nexo v6.7.0 https://theme-next.org 安装Git下载地址：https://pan.baidu.com/s/1zqsvaxXrnF_AYY4iYkcgVw 安装Node.js下载地址：https://nodejs.org/dist/v11.6.0/node-v11.6.0-x64.msi 安装 Hexo使用 npm 安装 Hexo。1npm install -g hexo-cli 安装完成后，在Windows系统的cmd命令窗口可以正常执行hexo命令，但是在Git Bash命令窗口执行hexo命令时，提示错误。12ERROR Local hexo not found in C:\tecchenERROR Try running: 'npm install hexo --save' 只好在当前目录执行npm install hexo –save，安装到项目目录中。1npm install hexo --save 建站初始化，可以不指定目录，则在当前目录完成初始化。123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install --save --registry=https://registry.npm.taobao.org 安装服务器Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。12npm install hexo-server --savehexo server 启动服务器，默认端口4000，可使用-p修改端口 可以略写为hexo s 使用浏览器，访问http://localhost:4000 即可看到默认的主页。 切换主题进入hexo根目录，执行以下命令该命令会创建themes/next目录，并clone Next主题。1git clone https://github.com/theme-next/hexo-theme-next themes/next 与所有 Hexo主题启用的模式一样。当克隆/下载完成后，打开站点配置文件，找到theme字段，并将其值更改为next。1theme: next 修改语言修改站点配置文件，将language设置为zh-CN，将博客设置为中文。1language: zh-CN 重启服务器，并访问http://localhost:4000 即可看到Next主题下的Hexo主页。 hexo的其他命令123hexo clean # 清理缓存文件 (db.json) 和已生成的静态文件 (public)hexo generate # 生成静态文件 可以略写为 hexo ghexo deploy # 部署，将public文件夹下的静态文件上传到指定的目标（推荐Git），完成部署 可以略写为hexo d]]></content>
      <categories>
        <category>Hexo博客系列</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最新版IntelliJ IDEA2019.1破解教程(2019.04.08更新)]]></title>
    <url>%2Fidea-crack.html</url>
    <content type="text"><![CDATA[目录 0、打赏记录 1、阿里云服务器广告 2、适用版本（适用于Windows及MacOS系统） 3、下载补丁 4、jetbrains-agent-v1.3.2-release.jar 5、JetbrainsIdesCrack-4.2-release.jar 6、激活成功 7、更改配置【推荐】 部分打赏记录打赏请备注网名及邮箱，谢谢～完整的打赏记录请查看完整打赏记录 土豪网友 邮箱 打赏方式 打赏金额 打赏时间 *一江 支付宝 ¥10.00 2019-01-27 19:11:00 *二勇 550***@qq.com 支付宝 ¥10.00 2019-02-18 15:27:00 *举 支付宝 ¥5.00 2019-02-22 12:41:00 *育龙 支付宝 ¥10.00 2019-03-11 15:20:00 *敏生 支付宝 ¥10.00 2019-03-15 17:08:00 *胜 微信 ¥10.00 2019-03-27 18:38:27 *鑫 微信 ¥10.00 2019-04-11 18:52:12 *遗 lid617 微信 ¥10.00 2019-04-12 10:26:53 特此感谢 适用版本（适用于Windows及MacOS系统） 补丁文件名 适合Idea版本 Windows验证 Mac验证 jetbrains-agent-v1.3.2-release.jar IntelliJ IDEA 2019.1及以下 已验证 已验证 JetbrainsIdesCrack-4.2-release.jar IntelliJ IDEA 2018.3.4及以下 已验证 已验证 JetbrainsCrack-3.4-release-enc.jar IntelliJ IDEA 2018.3.2及以下 已验证 已验证 JetbrainsCrack-3.1-release-enc.jar IntelliJ IDEA 2018.2.x 已验证 已验证 阿里云服务器广告当你拥有了一个独立服务器，一个独立域名，一个独立IP时，你可以做很多之前不能做的事！来和我一起拥抱阿里云服务吧！已经加入购买阿里云服务的技术小伙伴，你也来上榜呀！【开年HI购季】爆款云产品5折(适用于个人)【全民云计算】云主机低至2折(适用于企业)【助力企业上云】性能级主机2-5折【超高返现】购物车全产品返25% 下载补丁下载补丁前，进行最最重要的一步：将电脑上的idea卸载，不要覆盖安装，否则可能出现key无效，破解失败的情况。下载后，将补丁jar包复制到idea安装目录的bin下面，例如我的安装目录是D:\Idea_2018.2.4，我会将破解jar包放到这里。 下载地址：（如发现下载链接失效，请通过QQ邮箱359031282@qq.com联系我，谢谢~）感谢3386+的小伙伴点亮了下载链接，有你们分享，开发的世界更宽广～扫描二维码，获取补丁下载方式 更多软件开发资源下载：详见我的另外一篇博客：《软件开发资源下载》 jetbrains-agent-v1.3.2-release.jar修改配置文件可仅修改Idea安装目录下的idea64.exe.vmoptions；如果需要使用x86版本，可同步修改idea.exe.vmoptions；MacOS修改idea.vmoptions。只需要在文件后追加-javaagent:D:\IntelliJ_IDEA_2018.3.4\bin\jetbrains-agent-v1.3.2-release.jar即可。其中D:\IntelliJ_IDEA_2018.3.4是我的idea安装目录哦，你按照自己安装的位置，进行适当的调整。修改后的idea64.exe.vmoptions12345678910111213-Xms128m-Xmx750m-XX:ReservedCodeCacheSize=240m-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50-ea-Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-Djdk.http.auth.tunneling.disabledSchemes=""-XX:+HeapDumpOnOutOfMemoryError-XX:-OmitStackTraceInFastThrow-javaagent:D:\IntelliJ_IDEA_2018.3.4\bin\jetbrains-agent-v1.3.2-release.jar 输入激活码启动idea，在IntelliJ IDEA License Activation界面的，选择License server并输入以下地址：1http://jetbrains-license-server 点击Test Connection，提示成功，点击激活即可使用。 JetbrainsIdesCrack-4.2-release.jar修改配置文件可仅修改Idea安装目录下的idea64.exe.vmoptions；如果需要使用x86版本，可同步修改idea.exe.vmoptions；MacOS修改idea.vmoptions。只需要在文件后追加-javaagent:D:\IntelliJ_IDEA_2018.3.3\bin\JetbrainsIdesCrack-4.2-release.jar即可。其中D:\IntelliJ_IDEA_2018.3.3是我的idea安装目录哦，你按照自己安装的位置，进行适当的调整。修改后的idea64.exe.vmoptions12345678910111213-Xms128m-Xmx750m-XX:ReservedCodeCacheSize=240m-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50-ea-Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-Djdk.http.auth.tunneling.disabledSchemes=""-XX:+HeapDumpOnOutOfMemoryError-XX:-OmitStackTraceInFastThrow-javaagent:D:\IntelliJ_IDEA_2018.3.3\bin\JetbrainsIdesCrack-4.2-release.jar 输入激活码启动idea，在进入出现有active code选择界面的时候 写入下面注册代码：（到2099-12-31到期）123456789101112131415161718192021222324ThisCrackLicenseId-&#123;"licenseId":"ThisCrackLicenseId","licenseeName":"Candy","assigneeName":"","assigneeEmail":"Candy@qq.com","licenseRestriction":"For This Crack, Only Test! Please support genuine!!!","checkConcurrentUse":false,"products":[&#123;"code":"II","paidUpTo":"2099-12-30"&#125;,&#123;"code":"DM","paidUpTo":"2099-12-30"&#125;,&#123;"code":"AC","paidUpTo":"2099-12-30"&#125;,&#123;"code":"RS0","paidUpTo":"2099-12-30"&#125;,&#123;"code":"WS","paidUpTo":"2099-12-30"&#125;,&#123;"code":"DPN","paidUpTo":"2099-12-30"&#125;,&#123;"code":"RC","paidUpTo":"2099-12-30"&#125;,&#123;"code":"PS","paidUpTo":"2099-12-30"&#125;,&#123;"code":"DC","paidUpTo":"2099-12-30"&#125;,&#123;"code":"RM","paidUpTo":"2099-12-30"&#125;,&#123;"code":"CL","paidUpTo":"2099-12-30"&#125;,&#123;"code":"PC","paidUpTo":"2099-12-30"&#125;],"hash":"2911276/0","gracePeriodDays":7,"autoProlongated":false&#125; 激活成功成功截图： 更改配置【推荐】详见我的另外一篇博客《使用IntelliJ IDEA 前最好修改的配置》 下面就可以愉快的编码了。撒花庆祝！！！]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>IDEA</tag>
        <tag>最新版IDEA破解教程</tag>
        <tag>IDEA破解教程</tag>
        <tag>最新版idea破解教程</tag>
        <tag>idea破解教程</tag>
      </tags>
  </entry>
</search>
